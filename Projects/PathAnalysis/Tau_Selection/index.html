<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <script type="text/javascript" async 
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PPD τ Selection Visualization</title>
    <a href="prev_report.html">Previous Report</a>
    <style>
        body { font-family: Arial, Helvetica, sans-serif; text-align: center; margin: 0; padding: 20px; }
        h1 { font-size: 35px; color: #333; }
        h2 { font-size: 30px; color: #333; }
        p { 
            font-size: 35px;
            text-align: left;  /* Align paragraph text to the left */
            max-width: 80%;    /* Optional: Control width for better readability */
            margin: 0 auto;    /* Keeps it centered within the layout */
        }        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #dataset-container {
            margin: 10px 0;
            text-align: center;
        }
        
        /* Style the label */
        #dataset-container label {
            font-size: 25px;
            font-weight: bold;
            margin-right: 8px;
        }

        #dataset-container2 {
            margin: 10px 0;
            text-align: center;
        }
        
        /* Style the label */
        #dataset-container2 label {
            font-size: 25px;
            font-weight: bold;
            margin-right: 8px;
        }

        /* Style the dropdown select box */
        #datasetSelector {
            font-size: 25px;
            padding: 8px 12px;
            border: 2px solid #007bff;
            border-radius: 6px;
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
        }
        #datasetSelector2{
            font-size: 25px;
            padding: 8px 12px;
            border: 2px solid #007bff;
            border-radius: 6px;
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
        }
                
        #plots-wrapper {
            display: grid;
            grid-template-columns: repeat(2, minmax(50vh, 1fr)); /* Two columns, keeping a min width */
            grid-auto-rows: 42vh; /* Keep rows at 50vh height */
            gap: 25px; /* Space between plots */
            justify-content: center;
        }

        .plot-container {
            background: #f0f0f0;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%; /* Fill grid cell */
            height: 100%; /* Fill grid cell */
        }

        /* Ensure top-bar aligns legend & slider */
        #top-bar {
            display: flex;
            justify-content: center; /* Push legend & slider apart */
            align-items: center;
            gap: 40px;  /* Adjust spacing between legend & slider */
            width: 100%;
            margin-bottom: 10px; /* Add spacing before plots */
            margin-top: 10px; /* Add spacing before plots */
        }

        /* Legend layout */
        #legend-container {
            display: flex;
            gap: 25px;  /* Add spacing between legend items */
            align-items: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 25px;
            white-space: nowrap;
        }

        .legend-box {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 1px solid #000;
        }

        /* Slider layout */
        #slider-container {
            display: flex;
            align-items: center;
            gap: 10px; /* Spacing between text and slider */
            font-size: 25px;
        }

        #lambdaOptValue0 {
            font-weight: bold;
        }

        #lambdaOptValue2 {
            font-weight: bold;
        }

        #percValue {
            font-weight: bold;
        }

        #lambdaValue {
            font-weight: bold;
        }

        #plots-wrapper2 {
            display: grid;
            grid-template-columns: 50vh; /* Only one column */
            grid-auto-rows: 42vh; /* Maintain row height */
            gap: 25px; /* Space between plots */
            justify-content: center;
        }
        
    </style>
    </head>
    <body>
        <h1> Insensitivity of the new sequential algorithm </h1>    
        <p> 
            These visualizations compare the new sequential alignment algorithm with the previous approach. 
            The 2×2 panels below display alignment results for different \(\tau\) values, along with their corresponding \( \lambda^* \) values.
            The first row represents the previous algorithm, while the second row shows the new algorithm.
            <br><br>
            From this visualization, I want to infer the <span style="font-weight: bold">insensitivity </span> of the new algorithm to \(\tau\), which can be a significant advantage over the previous algorithm.
            <br><br>
            The main point I wanted to emphasize is that the variation of \(\hat{g}_\lambda\) is much smaller in the new algorithm. 
            You can compare the \(\hat{g}_0\) of both algorithms which are indicated by teal-colored line in the right column.
            This suggests that the new method at least avoid excessive alignments seen in \(\hat{g}_0\) of the previous approach.
            <br><br>
            Additionally, he new algorithm results in a slower change in \(\hat{g}_\lambda\) for small \(\lambda\) values, allowing for a smoother transition in the second row.
            You can further explore this in the interactive plot below (<a href="#target">Plot 2</a>).
        </p>

        <div id="dataset-container">   

            <label for="datasetSelector">Select Dataset:</label>
            <select id="datasetSelector">
                <option value="data1.json">Dataset 1</option>
                <option value="data2.json">Dataset 2</option>
                <option value="data3.json">Dataset 3</option>
                <option value="data4.json">Dataset 4</option>
                <option value="covid_death.json">RealData COVID Death_rate</option>
                <option value="covid_hosp.json">RealData COVID Hosp_rate</option>
                <option value="covid_infection.json">RealData COVID Infec_rate</option>
                <option value="elec_jan.json">RealData Elec_jan</option>
                <option value="elec_jul.json">RealData Elec_jul</option>
                <option value="female.json">RealData Female Growth</option>
                <option value="male.json">RealData Male Growth</option>
                <option value="air.json">RealData Air</option>
                <option value="bci.json">RealData BCI</option>
                <option value="cci.json">RealData CCI</option>
                <option value="gdp.json">RealData GDP_changes</option>
                <option value="stock.json">RealData Stock_changes</option>
                <option value="birth_rate.json">RealData Birth_rate</option>
            </select>
        </div>

        <div class="container">

            <!-- Legend + Slider Row -->
            <div id="top-bar">
                <!-- Legend -->
                <div id="legend-container">

                    <div class="legend-item" id="legend-g">
                        <span class="legend-box" style="background-color: #ff0000;"></span> 
                        \(g\)
                    </div>
                    <div class="legend-item">
                        <span class="legend-box" style="background-color: rgba(0, 153, 153, 0.5);"></span> 
                        \( \hat{g}_{0}\)
                    </div>
                    <div class="legend-item">
                        <span class="legend-box" style="background-color: rgba(170, 170, 0, 0.5);"></span> 
                        \( \hat{g}_{\infty} \)
                    </div>
                </div>
    
                <!-- Slider -->
                <div id="slider-container">
                    <label for="percSlider"> Percentile (<span id="percValue">15</span>%):</label>
                    <input type="range" id="percSlider" min="0" max="100" value="15" step="1">
                </div>
            </div>
            
            <div class="legend-item">
                (Prev) &nbsp; <span class="legend-box" style="background-color: #00ffff;"></span> 
                    \( \hat{g}_{\lambda^* \mid \text{perc}} \) ( \( \lambda^* \) = <span id="lambdaOptValue0"></span> )
            </div>

            <!-- Plots -->
            <div id="plots-wrapper">
                <div id="plot-container0-3d" class="plot-container"></div>
                <div id="plot-container0-2d" class="plot-container"></div>
            </div>
            <div class="legend-item">
                (New) &nbsp; <span class="legend-box" style="background-color: #00ffff;"></span> 
                \( \hat{g}_{\lambda^* \mid \text{perc}} \) ( \( \lambda^* \) = <span id="lambdaOptValue2"></span> )
            </div>
            <div id="plots-wrapper">
                <div id="plot-container2-3d" class="plot-container"></div>
                <div id="plot-container2-2d" class="plot-container"></div>
            </div>
        </div>

        <h2>Alignment Comparison of \(\hat{g}_{\lambda}\) in Two Different Algorithms</h2>

        <p>
            By adjusting the \(\lambda\) values, you can observe how \(\hat{g}_{\lambda}\) evolves in both algorithms.
            The <span style="font-weight: bold">pink line</span> represents the previous algorithm, 
            while the <span style="font-weight: bold">grey line</span> represents the new algorithm, as indicated in the legend.
        </p>
        
        <p>
            In most cases, the previous method tends to <span style="font-weight: bold">over-align</span> \(f_i\)'s, leading to sharp peaks in \(\hat{g}_{\lambda}\).
            This effect is particularly noticeable in the \(\texttt{Electricity-January}\) dataset, where peak locations shift dramatically.
            <br><br>
            In contrast, the new sequential method provides more stable alignment, preserving peak locations from \(\hat{g}_{\infty}\) and reducing excessive distortions.
        </p>
       

        <div id="target">
            <!-- <h2>This is the Target Section</h2>
            <p>You have arrived here by clicking the internal link.</p> -->
            <a href="#">Back to top</a> <!-- Link to return to top -->
        </div>
        <!-- add slider for lambda -->
        <!-- max of lambda should be changed by the data. data has lam_og -->
         <!-- Duplicate Dataset Selector for fig2 -->
        <div id="dataset-container2">
            <label for="datasetSelector2">Select Dataset:</label>
            <select id="datasetSelector2">
                <option value="data1.json">Dataset 1</option>
                <option value="data2.json">Dataset 2</option>
                <option value="data3.json">Dataset 3</option>
                <option value="data4.json">Dataset 4</option>
                <option value="covid_death.json">RealData COVID Death_rate</option>
                <option value="covid_hosp.json">RealData COVID Hosp_rate</option>
                <option value="covid_infection.json">RealData COVID Infec_rate</option>
                <option value="elec_jan.json">RealData Elec_jan</option>
                <option value="elec_jul.json">RealData Elec_jul</option>
                <option value="female.json">RealData Female Growth</option>
                <option value="male.json">RealData Male Growth</option>
                <option value="air.json">RealData Air</option>
                <option value="bci.json">RealData BCI</option>
                <option value="cci.json">RealData CCI</option>
                <option value="gdp.json">RealData GDP_changes</option>
                <option value="stock.json">RealData Stock_changes</option>
                <option value="birth_rate.json">RealData Birth_rate</option>
            </select>
        </div>


        <div class="container">

            <!-- Legend + Slider Row -->
            <div id="top-bar">
                <!-- Legend -->
                <div id="legend-container">

                    <div class="legend-item" id="legend-g">
                        <span class="legend-box" style="background-color: #ff0000;"></span> 
                        \(g\)
                    </div>
                    <div class="legend-item">
                        <span class="legend-box" style="background-color: rgb(255, 170, 255);"></span> 
                        (Prev) \( \,\, \hat{g}_{\lambda}\)
                    </div>

                    <div class="legend-item">
                        <span class="legend-box" style="background-color: rgb(241, 241, 241);"></span> 
                        (New) \( \,\, \hat{g}_{\lambda} \)
                    </div>
                </div>
    
                <!-- Slider -->
                <div id="slider-container">
                    <label for="lambdaSlider">\(\lambda\)(<span id="lambdaValue"> </span>):</label>
                    <input type="range" id="lambdaSlider" min="0" value="0" step="1">
                </div>
            </div>
        </div>
        <div id="plots-wrapper2">
            <div id="plot-container-2d" class="plot-container"></div>
        </div>

        </div>




        




  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
    import { Line2 } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/Line2.js';
    import { LineMaterial } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineMaterial.js';
    import { LineGeometry } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/lines/LineGeometry.js';

    
    let M, L, K0, x, lam, lam_og, perc, sigMat0, ghat0, peakHeight0, peakLoc0, IdxOpt0, g;
    let K2, sigMat2, ghat2, peakHeight2, peakLoc2, IdxOpt2;
    let ghat00, ghat22, gg;

    let scene3D0, camera3D0, renderer3D0, controls3D0, surfaceMesh0, selectedLine0, lambdaOptLine0;
    let scene3D2, camera3D2, renderer3D2, controls3D2, surfaceMesh2, selectedLine2, lambdaOptLine2;
    
    let scene2D0, camera2D0, renderer2D0, selected2DLine0
    let scene2D2, camera2D2, renderer2D2, selected2DLine2

    let scene_fig2, camera_fig2, renderer_fig2, selectedLine0_fig2, selectedLine2_fig2, gLine_fig2;

    let peakLines0, peakPoints0;
    let peakLines2, peakPoints2;

    let g2DLine0 = null; let g2DLine2 = null;
    let g3DLine0 = null; let g3DLine2 = null;

    let markerObjects2D0 = [];  // Store 2D markers for easy updates
    let markerObjects2D2 = [];

    let isSyncing = false;

    async function loadData(datasetFile) {
        const response = await fetch(datasetFile);
        const data = await response.json();
        
        return {
            M: data.x.length,
            L: data.lam.length,
            K: data.peakHeight[0].length,
            x: data.x,
            g: data.g,
            lam_og: [...data.lam],
            lam: [...data.lam].reverse(),
            ghat: data.ghat,
            peakHeight: data.peakHeight,
            peakLoc: data.peakLoc,
            sigMat: data.sigMat,
            IdxOpt: data.IdxOpt  // Store optimal lambda indices
        };
    }

    async function createPlots(datasetFile) {
        console.log("Loading dataset:", `data0/${datasetFile}`);
        ({ M: M, L: L, K: K0, x: x, lam: lam, lam_og: lam_og, ghat: ghat0, 
           IdxOpt: IdxOpt0, peakHeight: peakHeight0, peakLoc: peakLoc0, sigMat: sigMat0 } = await loadData(`data0/${datasetFile}`));

        console.log("Loading dataset:", `data2/${datasetFile}`);
        ({ K: K2, ghat: ghat2, 
           IdxOpt: IdxOpt2, peakHeight: peakHeight2, peakLoc: peakLoc2, sigMat: sigMat2, g: g} = await loadData(`data2/${datasetFile}`));
       
        scaleGhatToMatchLastRow();
        
        // get me the max value of lam
        let lam_max = Math.max(...lam);
        lam = lam.map(l => l/lam_max);
        
        updateLambdaSliderMax();

        updateLegend(g);

        percSlider.value = 15;

        // Ensure updates happen with 15 as the initial value
        updateLambdaOptValue0(15);
        updateLambdaOptValue2(15);

        // document.getElementById("lambdaSlider").max = L - 1;
        document.getElementById("percSlider").max = 100;

        create3DPlot0("plot-container0-3d", datasetFile);
        create2DPlot0(IdxOpt0 ? IdxOpt0[15] : 0);

        create3DPlot2("plot-container2-3d", datasetFile);
        create2DPlot2(IdxOpt2 ? IdxOpt2[15] : 0);

        createLambdaLine_fig2("plot-container-2d", datasetFile);

      
        updateLambdaOptValue0(15);  
        updateLambdaOptValue2(15);
        // create3DPlot2("plot-container2-3d", datasetFile);

        updateLamSelection(0);

        document.getElementById("percSlider").addEventListener("input", (event) => {
            let percValue = parseInt(event.target.value);
            document.getElementById("percValue").innerText = percValue;
            updateLambdaOptLine0(percValue);
            updateLambdaOptLine2(percValue);
        });
        
        document.getElementById("lambdaSlider").addEventListener("input", (event) => {
            const lambdaIdx = parseInt(event.target.value);
            updateLamSelection(lambdaIdx);
        });

        syncCameras();

    }

    function scaleGhatToMatchLastRow() {
        if (!ghat0 || !ghat2 || ghat0.length === 0 || ghat2.length === 0) {
            console.warn("ghat0 or ghat2 is missing; skipping scaling.");
            return;
        }

        // Extract the last row of ghat0 and ghat2
        const ghat0_last = ghat0[ghat0.length - 1];
        const ghat2_last = ghat2[ghat2.length - 1];

        // Compute scaling factor s
        // const s = ghat2_last.map((val, idx) => val / ghat0_last[idx]); // Element-wise division
        // Compute scaling factor s, avoiding division by zero
        
        const s = ghat2_last.map((val, idx) => {
            if (ghat0_last[idx] === 0) {
                return 1; // If denominator is zero, avoid NaN by setting scale to 1 (no scaling)
            }
            return val / ghat0_last[idx]; // Normal division otherwise
        });

        // console.log("Scaling factor (s):", s);

        // Apply the scaling factor to ghat0

        if (s[0] <= 1) {
            ghat00 = ghat0.map(row => row.map((val, idx) => val * s[idx]));
            ghat22 = ghat2;
            gg = g;
            // peakHeight0 = peakHeight0.map(row => row.map((val, idx) => val * s[idx]));
        } else {
            ghat00 = ghat0;
            ghat22 = ghat2.map(row => row.map((val, idx) => val / s[idx]));
            // peakHeight2 = peakHeight2.map(row => row.map((val, idx) => val / s[idx]));
            if (g!=null) gg = g.map((val, idx) => val / s[idx]);
        }

    }

    function create3DPlot0(containerId, datasetFile) {

        const container = document.getElementById(containerId);
        scene3D0 = new THREE.Scene();
        scene3D0.background = new THREE.Color(0x333333);
        
        camera3D0 = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000); 
        camera3D0.position.set(0.4,2.6,1.1);

        renderer3D0 = new THREE.WebGLRenderer({ antialias: true });
        renderer3D0.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer3D0.domElement);
        
        controls3D0 = new OrbitControls(camera3D0, renderer3D0.domElement);

        let centerX = (Math.min(...x) + Math.max(...x)) / 2;
        let centerY = (Math.min(...ghat0.flat(), ...ghat2.flat()) + Math.max(...ghat0.flat(), ...ghat2.flat())) / 2;
        let centerZ = (Math.min(...lam) + Math.max(...lam)) / 2;

        controls3D0.target.set(centerX, centerY, centerZ);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0.5, 2.5, 0).normalize();
        scene3D0.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene3D0.add(ambientLight);
        
        createSurfacePlot0();
        createPeakLines0(container);
        createLambdaOptLine0(container);

        updatePercSelection0(15);
        document.getElementById("percSlider").addEventListener("input", (event) => {
          updatePercSelection0(parseInt(event.target.value));
        });

        animate3D0();
    }
    function create3DPlot2(containerId, datasetFile) {
                
        const container = document.getElementById(containerId);
        scene3D2 = new THREE.Scene();
        scene3D2.background = new THREE.Color(0x333333);
        
        camera3D2 = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000); 
        camera3D2.position.set(0.4,2.6,1.1);

        renderer3D2 = new THREE.WebGLRenderer({ antialias: true });
        renderer3D2.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer3D2.domElement);
        
        controls3D2 = new OrbitControls(camera3D2, renderer3D2.domElement);

        let centerX = (Math.min(...x) + Math.max(...x)) / 2;
        let centerY = (Math.min(...ghat0.flat(), ...ghat2.flat()) + Math.max(...ghat0.flat(), ...ghat2.flat())) / 2;
        let centerZ = (Math.min(...lam) + Math.max(...lam)) / 2;

        controls3D2.target.set(centerX, centerY, centerZ);

        const light = new THREE.DirectionalLight(0xffffff, 1.5);
        light.position.set(0.5, 2.5, 0).normalize();
        scene3D2.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene3D2.add(ambientLight);
        
        createSurfacePlot2();
        createPeakLines2(container);
        createLambdaOptLine2(container);

        updatePercSelection2(15);
        document.getElementById("percSlider").addEventListener("input", (event) => {
            updatePercSelection2(parseInt(event.target.value));
        });

        // function animate3D() {
        //     requestAnimationFrame(animate3D);
        //     controls3D2.update();
        //     renderer3D2.render(scene3D2, camera3D2);
        // }
        animate3D2();
    }
        
    function create2DPlot0(optLambdaIdx0) {

        const container = document.getElementById("plot-container0-2d");
        scene2D0 = new THREE.Scene();
        scene2D0.background = new THREE.Color(0x333333);

        // Compute min/max values dynamically
        const xMin = Math.min(...x);
        const xMax = Math.max(...x);
        const yMin = Math.min(...ghat0.flat(), ...ghat2.flat());
        const yMax = Math.max(...ghat0.flat(), ...ghat2.flat());

        // Slightly extend axis ranges (optional)
        const padding = 0.05;
        const xRange = (xMax - xMin) * padding;
        const yRange = (yMax - yMin) * padding;

        // Adjust camera to fit the computed range
        camera2D0 = new THREE.OrthographicCamera(
            xMin - xRange, xMax + xRange, // left, right
            yMax + yRange, yMin - yRange, // top, bottom
            0.1, 1000
        );
        camera2D0.position.set(0, 0, 5);

        renderer2D0 = new THREE.WebGLRenderer({ antialias: true });
        renderer2D0.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer2D0.domElement);

        plot_ghat0_2DPlot0(0, 0x009999);   // First line (magenta)
        plot_ghat0_2DPlot0(L-1, 0xaaaa00); 

        if (g !== null) {
            plot_g_2DPlot0();
        }   
        
        update2DPlot0(optLambdaIdx0);

        function animate2D() {
            requestAnimationFrame(animate2D);
            renderer2D0.render(scene2D0, camera2D0);
        }

        animate2D();
    }
    function create2DPlot2(optLambdaIdx2) {

        const container = document.getElementById("plot-container2-2d");
        scene2D2 = new THREE.Scene();
        scene2D2.background = new THREE.Color(0x333333);

        // Compute min/max values dynamically
        const xMin = Math.min(...x);
        const xMax = Math.max(...x);
        const yMin = Math.min(...ghat0.flat(), ...ghat2.flat());
        const yMax = Math.max(...ghat0.flat(), ...ghat2.flat());

        // Slightly extend axis ranges (optional)
        const padding = 0.05;
        const xRange = (xMax - xMin) * padding;
        const yRange = (yMax - yMin) * padding;

        // Adjust camera to fit the computed range
        camera2D2 = new THREE.OrthographicCamera(
            xMin - xRange, xMax + xRange, // left, right
            yMax + yRange, yMin - yRange, // top, bottom
            0.1, 1000
        );
        camera2D2.position.set(0, 0, 5);

        renderer2D2 = new THREE.WebGLRenderer({ antialias: true });
        renderer2D2.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer2D2.domElement);

        plot_ghat2_2DPlot2(0, 0x009999);   // First line (magenta)
        plot_ghat2_2DPlot2(L-1, 0xaaaa00); 

        if (g !== null) {
            plot_g_2DPlot2();
        }   

        update2DPlot2(optLambdaIdx2);

        function animate2D() {
            requestAnimationFrame(animate2D);
            renderer2D2.render(scene2D2, camera2D2);
        }

        animate2D();
        }

    function update2DPlot0(optLambdaIdx0, selectedPerc = 15) {
        if (selected2DLine0) {
            scene2D0.remove(selected2DLine0);
        }

        // Draw the main curve
        const positions = [];
        for (let m = 0; m < M; m++) {
            positions.push(x[m], ghat0[optLambdaIdx0][m], 0);
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: 0x00ffff, // cyan line
            linewidth: 5,
        });
        lineMaterial.resolution.set(renderer2D0.domElement.width, renderer2D0.domElement.height);

        selected2DLine0 = new Line2(lineGeometry, lineMaterial);
        selected2DLine0.computeLineDistances();
        scene2D0.add(selected2DLine0);

        // Remove previous markers
        markerObjects2D0.forEach(marker => scene2D0.remove(marker));
        markerObjects2D0 = [];

        // Add markers (blue for normal peaks, grey for killed peaks)
        for (let k = 0; k < K0; k++) {
            let xVal = peakLoc0[optLambdaIdx0][k];
            let yVal = peakHeight0[optLambdaIdx0][k];

            if (xVal !== null && yVal !== null) {
                const markerGeometry = new THREE.SphereGeometry(0.02, 12, 12); // Small dot
                const isKilled = sigMat0[optLambdaIdx0][k] <= selectedPerc;
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: isKilled ? 0xaaaaaa : 0x000000
                });

                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(xVal, yVal, 0);
                scene2D0.add(marker);
                markerObjects2D0.push(marker);
            }
        }

        // Highlight **Optimal λ** markers in green
        if (optLambdaIdx0 !== null) {
            for (let k = 0; k < K0; k++) {
                let xVal = peakLoc0[optLambdaIdx0][k];
                let yVal = peakHeight0[optLambdaIdx0][k];

                if (xVal !== null && yVal !== null && sigMat0[optLambdaIdx0][k] > selectedPerc) {
                    const greenMarkerGeometry = new THREE.SphereGeometry(0.025, 12, 12); // Bigger dot
                    const greenMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffbb });

                    const greenMarker = new THREE.Mesh(greenMarkerGeometry, greenMarkerMaterial);
                    greenMarker.position.set(xVal, yVal, 0);
                    scene2D0.add(greenMarker);
                    markerObjects2D0.push(greenMarker);
                }
            }
        }
    }
    function update2DPlot2(optLambdaIdx2, selectedPerc = 15) {
        if (selected2DLine2) {
            scene2D2.remove(selected2DLine2);
        }

        // Draw the main curve
        const positions = [];
        for (let m = 0; m < M; m++) {
            positions.push(x[m], ghat2[optLambdaIdx2][m], 0);
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: 0x00ffff, // cyan line
            linewidth: 5,
        });
        lineMaterial.resolution.set(renderer2D2.domElement.width, renderer2D2.domElement.height);

        selected2DLine2 = new Line2(lineGeometry, lineMaterial);
        selected2DLine2.computeLineDistances();
        scene2D2.add(selected2DLine2);

        // Remove previous markers
        markerObjects2D2.forEach(marker => scene2D2.remove(marker));
        markerObjects2D2 = [];

        // Add markers (blue for normal peaks, grey for killed peaks)
        for (let k = 0; k < K2; k++) {
            let xVal = peakLoc2[optLambdaIdx2][k];
            let yVal = peakHeight2[optLambdaIdx2][k];

            if (xVal !== null && yVal !== null) {
                const markerGeometry = new THREE.SphereGeometry(0.02, 12, 12); // Small dot
                const isKilled = sigMat2[optLambdaIdx2][k] <= selectedPerc;
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: isKilled ? 0xaaaaaa : 0x000000
                });

                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(xVal, yVal, 0);
                scene2D2.add(marker);
                markerObjects2D2.push(marker);
            }
        }

        // Highlight **Optimal λ** markers in green
        if (optLambdaIdx2 !== null) {
            for (let k = 0; k < K2; k++) {
                let xVal = peakLoc2[optLambdaIdx2][k];
                let yVal = peakHeight2[optLambdaIdx2][k];

                if (xVal !== null && yVal !== null && sigMat2[optLambdaIdx2][k] > selectedPerc) {
                    const greenMarkerGeometry = new THREE.SphereGeometry(0.025, 12, 12); // Bigger dot
                    const greenMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffbb });

                    const greenMarker = new THREE.Mesh(greenMarkerGeometry, greenMarkerMaterial);
                    greenMarker.position.set(xVal, yVal, 0);
                    scene2D2.add(greenMarker);
                    markerObjects2D2.push(greenMarker);
                }
            }
        }
    }

    function plot_g_2DPlot0() {
        if (g2DLine0) {
            return; // Skip if already drawn (avoids redundant rendering)
        }

        const positions = [];

        for (let m = 0; m < M; m++) {
            positions.push(x[m], g[m], 0); // Flattened format for Line2
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: 0xff0000, // cyan
            linewidth: 3,    // Thicker line for visibility
        });
        lineMaterial.resolution.set(renderer2D0.domElement.width, renderer2D0.domElement.height);

        g2DLine0 = new Line2(lineGeometry, lineMaterial);
        g2DLine0.computeLineDistances();
        scene2D0.add(g2DLine0);
    }

    function plot_g_2DPlot2() {
        if (g2DLine2) {
            return; // Skip if already drawn (avoids redundant rendering)
        }

        const positions = [];

        for (let m = 0; m < M; m++) {
            positions.push(x[m], g[m], 0); // Flattened format for Line2
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: 0xff0000, // cyan
            linewidth: 3,    // Thicker line for visibility
        });
        lineMaterial.resolution.set(renderer2D2.domElement.width, renderer2D2.domElement.height);

        g2DLine2 = new Line2(lineGeometry, lineMaterial);
        g2DLine2.computeLineDistances();
        scene2D2.add(g2DLine2);
    }
    
    let ghat02DLines0 = []; // Store multiple lines
    let ghat02DLines2 = [];
    function plot_ghat0_2DPlot0(idx, colorHex) {
        // Create a new line instead of checking a single ghat02DLine
        const positions = [];

        for (let m = 0; m < M; m++) {
            positions.push(x[m], ghat0[idx][m], 0); // Flattened format for Line2
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: colorHex,
            linewidth: 3,    // Thicker line for visibility
            transparent: true,
            opacity: 0.3,
        });
        lineMaterial.resolution.set(renderer2D0.domElement.width, renderer2D0.domElement.height);

        const newLine = new Line2(lineGeometry, lineMaterial);
        newLine.computeLineDistances();
        scene2D0.add(newLine);

        ghat02DLines0.push(newLine); // Store the created line
    }
    function plot_ghat2_2DPlot2(idx, colorHex) {
        // Create a new line instead of checking a single ghat02DLine
        const positions = [];

        for (let m = 0; m < M; m++) {
            positions.push(x[m], ghat2[idx][m], 0); // Flattened format for Line2
        }

        const lineGeometry = new LineGeometry();
        lineGeometry.setPositions(positions);

        const lineMaterial = new LineMaterial({
            color: colorHex,
            linewidth: 3,    // Thicker line for visibility
            transparent: true,
            opacity: 0.3,
        });
        lineMaterial.resolution.set(renderer2D2.domElement.width, renderer2D2.domElement.height);

        const newLine = new Line2(lineGeometry, lineMaterial);
        newLine.computeLineDistances();
        scene2D2.add(newLine);

        ghat02DLines2.push(newLine); // Store the created line
    }
    
    function createSurfacePlot0() {
      // Create Surface Mesh
      const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array(M * L * 3);
        const indices = [];
        let index = 0;
        for (let l = 0; l < L; l++) {
          for (let m = 0; m < M; m++) {
            vertices[index++] = x[m];
            vertices[index++] = ghat0[l][m];
            vertices[index++] = lam[l];
          }
        }
        for (let l = 0; l < L - 1; l++) {
          for (let m = 0; m < M - 1; m++) {
            let a = l * M + m;
            let b = a + 1;
            let c = (l + 1) * M + m;
            let d = c + 1;
            indices.push(a, b, c, b, d, c);
          }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        // Set vertex colors
        const colors = new Float32Array(M * L * 3);
        const flatGhat = ghat0.flat();
        const minGhat = Math.min(...flatGhat);
        const maxGhat = Math.max(...flatGhat);
        let colorIndex = 0;
        for (let l = 0; l < L; l++) {
          for (let m = 0; m < M; m++) {
            let colorFactor = (ghat0[l][m] - minGhat) / (maxGhat - minGhat);
            colors[colorIndex++] = colorFactor;
            colors[colorIndex++] = 1 - colorFactor;
            colors[colorIndex++] = 0.6;
          }
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            depthWrite: false   // Prevents issues where opaque objects render over transparent ones
        });
        surfaceMesh0 = new THREE.Mesh(geometry, material);
        scene3D0.add(surfaceMesh0);
    }
    function createSurfacePlot2() {
      // Create Surface Mesh
      const geometry = new THREE.BufferGeometry();
        const vertices = new Float32Array(M * L * 3);
        const indices = [];
        let index = 0;
        for (let l = 0; l < L; l++) {
          for (let m = 0; m < M; m++) {
            vertices[index++] = x[m];
            vertices[index++] = ghat2[l][m];
            vertices[index++] = lam[l];
          }
        }
        for (let l = 0; l < L - 1; l++) {
          for (let m = 0; m < M - 1; m++) {
            let a = l * M + m;
            let b = a + 1;
            let c = (l + 1) * M + m;
            let d = c + 1;
            indices.push(a, b, c, b, d, c);
          }
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        
        // Set vertex colors
        const colors = new Float32Array(M * L * 3);
        const flatGhat = ghat2.flat();
        const minGhat = Math.min(...flatGhat);
        const maxGhat = Math.max(...flatGhat);
        let colorIndex = 0;
        for (let l = 0; l < L; l++) {
          for (let m = 0; m < M; m++) {
            let colorFactor = (ghat2[l][m] - minGhat) / (maxGhat - minGhat);
            colors[colorIndex++] = colorFactor;
            colors[colorIndex++] = 1 - colorFactor;
            colors[colorIndex++] = 0.6;
          }
        }
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshStandardMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.7,
            depthWrite: false   // Prevents issues where opaque objects render over transparent ones
        });
        surfaceMesh2 = new THREE.Mesh(geometry, material);
        scene3D2.add(surfaceMesh2);
    }


















    function createLambdaLine_fig2(containerId) {
        const container = document.getElementById(containerId);

        if (!scene_fig2) {
            scene_fig2 = new THREE.Scene();
            scene_fig2.background = new THREE.Color(0x000000); // Dark gray
        }

        const xMin = Math.min(...x);
        const xMax = Math.max(...x);
        const yMin = Math.min(...ghat00.flat(), ...ghat22.flat());
        const yMax = Math.max(...ghat00.flat(), ...ghat22.flat());

        // Slightly extend axis ranges (optional)
        const padding = 0.05;
        const xRange = (xMax - xMin) * padding;
        const yRange = (yMax - yMin) * padding;
        

        // Shared camera for both plots
        if (!camera_fig2) {
            camera_fig2 = new THREE.OrthographicCamera(
                xMin - xRange, xMax + xRange, // left, right
                yMax + yRange, yMin - yRange, // top, bottom
                0.1, 1000
            );
            camera_fig2.position.set(0, 0, 5);
        }


        if (!renderer_fig2) {
            renderer_fig2 = new THREE.WebGLRenderer({ antialias: true });
            renderer_fig2.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer_fig2.domElement);
        }

        if (g !== null) {
            //  Create line for g(x)
            if (!gLine_fig2) {
                const positions = [];
                for (let m = 0; m < M; m++) {
                    positions.push(x[m], gg[m], 0);
                }

                const lineGeometryG = new LineGeometry();
                lineGeometryG.setPositions(positions);

                const lineMaterialG = new LineMaterial({
                    color: 0xff0000, // Red for g(x)
                    linewidth: 3,
                });
                lineMaterialG.resolution.set(renderer_fig2.domElement.width, renderer_fig2.domElement.height);

                gLine_fig2 = new Line2(lineGeometryG, lineMaterialG);
                gLine_fig2.computeLineDistances();
                scene_fig2.add(gLine_fig2);
            }
        }

        //  Create lambda lines
        const lambdaLineGeometry0 = new LineGeometry();
        const lambdaLineGeometry2 = new LineGeometry();

        const linePositions0 = [];
        const linePositions2 = [];

        for (let m = 0; m < M; m++) {
            linePositions0.push(x[m], ghat0[0][m], 0); // Using correct lam0[0]
        }
        for (let m = 0; m < M; m++) {
            linePositions2.push(x[m], ghat2[0][m], 0); // Using correct lam2[0]
        }

        lambdaLineGeometry0.setPositions(linePositions0);
        lambdaLineGeometry2.setPositions(linePositions2);

        const lambdaLineMaterial0 = new LineMaterial({
            color: 0xFFAAFF, // Equivalent to RGB (215, 156, 37)
            linewidth: 5,
            transparent: true, // Enable transparency
            opacity: 1, // Set alpha value
        });
        lambdaLineMaterial0.resolution.set(container.clientWidth, container.clientHeight);

        const lambdaLineMaterial2 = new LineMaterial({
            color: 0xF1F1F1, // Equivalent to RGB (97, 213, 19)
            linewidth: 5,
            transparent: true, // Enable transparency
            opacity: 1, // Set alpha value
        });
        lambdaLineMaterial2.resolution.set(container.clientWidth, container.clientHeight);

        // Assign globally to be accessed later
        selectedLine0_fig2 = new Line2(lambdaLineGeometry0, lambdaLineMaterial0);
        selectedLine2_fig2 = new Line2(lambdaLineGeometry2, lambdaLineMaterial2);

        selectedLine0_fig2.computeLineDistances();
        selectedLine2_fig2.computeLineDistances();

        scene_fig2.add(selectedLine0_fig2);
        scene_fig2.add(selectedLine2_fig2);

        function animate_fig2() {
            requestAnimationFrame(animate_fig2);
            renderer_fig2.render(scene_fig2, camera_fig2);
        }
        animate_fig2();
    }

    function createLambdaOptLine0(container) {
        const linePositions = [];
        const gPositions = [];  // To store g(x) positions

        let optLambdaIdx0 = IdxOpt0 ? IdxOpt0[15] : 0;

        for (let m = 0; m < M; m++) {
            linePositions.push(x[m], ghat0[optLambdaIdx0][m], lam[optLambdaIdx0]); // λ* Curve
            if (g!==null) gPositions.push(x[m], g[m], lam[optLambdaIdx0]); // g(x) Curve at same λ*
        }

        // Draw λ* Line
        const optLineGeometry = new LineGeometry();
        optLineGeometry.setPositions(linePositions);
        const optLineMaterial = new LineMaterial({
            color: 0x00ffff, // Cyan for λ*
            linewidth: 5,
        });
        optLineMaterial.resolution.set(container.clientWidth, container.clientHeight);
        lambdaOptLine0 = new Line2(optLineGeometry, optLineMaterial);
        lambdaOptLine0.computeLineDistances();
        scene3D0.add(lambdaOptLine0);

        if (g !== null) {
            // Draw g(x) Line (Store globally!)
            const gLineGeometry = new LineGeometry();
            gLineGeometry.setPositions(gPositions);
            const gLineMaterial = new LineMaterial({
                color: 0xff0000, // Red for g(x)
                linewidth: 3,
            });
            gLineMaterial.resolution.set(container.clientWidth, container.clientHeight);
            
            g3DLine0 = new Line2(gLineGeometry, gLineMaterial);  // Store g3DLine globally
            g3DLine0.computeLineDistances();
            scene3D0.add(g3DLine0);
        }
    }
    function createLambdaOptLine2(container) {
        const linePositions = [];
        const gPositions = [];  // To store g(x) positions

        let optLambdaIdx2 = IdxOpt2 ? IdxOpt2[15] : 0;

        for (let m = 0; m < M; m++) {
            linePositions.push(x[m], ghat2[optLambdaIdx2][m], lam[optLambdaIdx2]); // λ* Curve
            if (g!==null) gPositions.push(x[m], g[m], lam[optLambdaIdx2]); // g(x) Curve at same λ*
        }

        // Draw λ* Line
        const optLineGeometry = new LineGeometry();
        optLineGeometry.setPositions(linePositions);
        const optLineMaterial = new LineMaterial({
            color: 0x00ffff, // Cyan for λ*
            linewidth: 5,
        });
        optLineMaterial.resolution.set(container.clientWidth, container.clientHeight);
        lambdaOptLine2 = new Line2(optLineGeometry, optLineMaterial);
        lambdaOptLine2.computeLineDistances();
        scene3D2.add(lambdaOptLine2);

        if (g !== null) {
            // Draw g(x) Line (Store globally!)
            const gLineGeometry = new LineGeometry();
            gLineGeometry.setPositions(gPositions);
            const gLineMaterial = new LineMaterial({
                color: 0xff0000, // Red for g(x)
                linewidth: 3,
            });
            gLineMaterial.resolution.set(container.clientWidth, container.clientHeight);
            
            g3DLine2 = new Line2(gLineGeometry, gLineMaterial);  // Store g3DLine globally
            g3DLine2.computeLineDistances();
            scene3D2.add(g3DLine2);
        }
    }

    function createPeakLines0(container) {
        peakLines0 = []; // Store references for updates
        peakPoints0 = [];
        
        for (let k = 0; k < K0; k++) {
            let peakPositions = [];
            let markerObjects = [];
            let segment = [];

            for (let l = 0; l < L; l++) {
                let xVal = peakLoc0[l][k];
                let zVal = lam[l];
                let yVal = peakHeight0[l][k];

                if (xVal !== null && yVal !== null) {
                    segment.push(xVal, yVal, zVal);

                    const sphereGeometry = new THREE.SphereGeometry(0.02, 12, 12); // Small & smooth
                    const sphereMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        transparent: true
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.set(xVal, yVal, zVal);
                    scene3D0.add(sphere);
                    
                    markerObjects.push(sphere); // Store marker for later updates
                } else {
                    if (segment.length > 0) {
                        peakPositions.push([...segment]);  // Store valid segment
                        segment = []; // Reset for a new segment
                    }
                    markerObjects.push(null); 
                }


            }
            peakPoints0.push(markerObjects);
            
            if (segment.length > 0) {
                peakPositions.push([...segment]);
            }

            if (peakPositions.length > 0) { 
                const peakGeometry = new LineGeometry();
                peakGeometry.setPositions(peakPositions.flat());

                // Define colors array dynamically
                const colors = new Float32Array(peakPositions.flat().length); // One color per vertex (RGB)
                
                for (let i = 0; i < colors.length; i += 3) {
                    colors[i] = 0.0;    // Red
                    colors[i+1] = 1.0;  // Green
                    colors[i+2] = 0.0;  // Blue
                }

                peakGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const peakMaterial = new LineMaterial({
                    vertexColors: true,  // Enable per-vertex colors
                    linewidth: 2,
                });
                peakMaterial.resolution.set(container.clientWidth, container.clientHeight);

                const peakLine = new Line2(peakGeometry, peakMaterial);
                peakLine.computeLineDistances();
                scene3D0.add(peakLine);
                peakLines0.push({ peakLine, k });
            }            
        }
    }
    function createPeakLines2(container) {
        peakLines2 = []; // Store references for updates
        peakPoints2 = [];
        
        for (let k = 0; k < K2; k++) {
            let peakPositions = [];
            let markerObjects = [];
            let segment = [];

            for (let l = 0; l < L; l++) {
                let xVal = peakLoc2[l][k];
                let zVal = lam[l];
                let yVal = peakHeight2[l][k];

                if (xVal !== null && yVal !== null) {
                    segment.push(xVal, yVal, zVal);

                    const sphereGeometry = new THREE.SphereGeometry(0.02, 12, 12); // Small & smooth
                    const sphereMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x000000,
                        transparent: true
                    });
                    
                    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    sphere.position.set(xVal, yVal, zVal);
                    scene3D2.add(sphere);
                    
                    markerObjects.push(sphere); // Store marker for later updates
                } else {
                    if (segment.length > 0) {
                        peakPositions.push([...segment]);  // Store valid segment
                        segment = []; // Reset for a new segment
                    }
                    markerObjects.push(null); 
                }


            }
            peakPoints2.push(markerObjects);
            
            if (segment.length > 0) {
                peakPositions.push([...segment]);
            }

            if (peakPositions.length > 0) { 
                const peakGeometry = new LineGeometry();
                peakGeometry.setPositions(peakPositions.flat());

                // Define colors array dynamically
                const colors = new Float32Array(peakPositions.flat().length); // One color per vertex (RGB)
                
                for (let i = 0; i < colors.length; i += 3) {
                    colors[i] = 0.0;    // Red
                    colors[i+1] = 1.0;  // Green
                    colors[i+2] = 0.0;  // Blue
                }

                peakGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const peakMaterial = new LineMaterial({
                    vertexColors: true,  // Enable per-vertex colors
                    linewidth: 2,
                });
                peakMaterial.resolution.set(container.clientWidth, container.clientHeight);

                const peakLine = new Line2(peakGeometry, peakMaterial);
                peakLine.computeLineDistances();
                scene3D2.add(peakLine);
                peakLines2.push({ peakLine, k });
            }            
        }
    }
    // update function for legend
    function updateLambdaOptValue0(selectedPerc = 15) {
        if (IdxOpt0 && lam_og) {
            let optLambdaIdx0 = IdxOpt0[selectedPerc] ?? IdxOpt0[15]; // Ensure valid index

            if (optLambdaIdx0 !== undefined) {
                let lambdaOptValue0 = lam_og[optLambdaIdx0].toFixed(2);
                document.getElementById("lambdaOptValue0").innerText = lambdaOptValue0;
            } else {
                console.warn("Invalid optLambdaIdx0:", optLambdaIdx0);
            }
        }
    }
    function updateLambdaOptValue2(selectedPerc = 15) {
        if (IdxOpt2 && lam_og) {
            let optLambdaIdx2 = IdxOpt2[selectedPerc] ?? IdxOpt2[15]; // Ensure valid index

            if (optLambdaIdx2 !== undefined) {
                let lambdaOptValue2 = lam_og[optLambdaIdx2].toFixed(2);
                document.getElementById("lambdaOptValue2").innerText = lambdaOptValue2;
            } else {
                console.warn("Invalid optLambdaIdx2:", optLambdaIdx2);
            }
        }
    }

    
    function updateLamSelection(selectedLambdaIdx) {
        // Check if `lam_og` is defined and `selectedLambdaIdx` is within bounds
        if (!lam_og || selectedLambdaIdx < 0 || selectedLambdaIdx >= lam_og.length) {
            console.error("Invalid lambda index:", selectedLambdaIdx);
            return;
        }

        document.getElementById("lambdaValue").innerText = lam_og[selectedLambdaIdx]?.toFixed(2) || "N/A";

        const newPositions0 = [];
        const newPositions2 = [];

        for (let m = 0; m < M; m++) {
            if (ghat00[selectedLambdaIdx] && ghat00[selectedLambdaIdx][m] !== undefined) {
                newPositions0.push(x[m], ghat00[selectedLambdaIdx][m], 0 || 0);
            }
        }
        for (let m = 0; m < M; m++) {
            if (ghat22[selectedLambdaIdx] && ghat22[selectedLambdaIdx][m] !== undefined) {
                newPositions2.push(x[m], ghat22[selectedLambdaIdx][m], 0 || 0);
            }
        }

        // Ensure lambda lines exist before updating
        if (!selectedLine0_fig2 || !selectedLine2_fig2) {
            console.warn("Creating lambda lines since they were undefined...");
            createLambdaLine_fig2("plot-container-2d");
        }
        

        selectedLine0_fig2.geometry.setPositions(newPositions0);
        selectedLine2_fig2.geometry.setPositions(newPositions2);

        selectedLine0_fig2.material.resolution.set(
            document.getElementById("plot-container-2d").clientWidth,
            document.getElementById("plot-container-2d").clientHeight
        );
        selectedLine2_fig2.material.resolution.set(
            document.getElementById("plot-container-2d").clientWidth,
            document.getElementById("plot-container-2d").clientHeight
        );
    }
    function updateLambdaSliderMax() {
        const lambdaSlider = document.getElementById("lambdaSlider");

        if (!lam_og || lam_og.length === 0) {
            console.warn("lam_og is empty or undefined. Setting lambda slider max to 0.");
            lambdaSlider.max = 0;
            return;
        }

        lambdaSlider.max = lam_og.length - 1;
        console.log(`Lambda slider max set to: ${lambdaSlider.max}`);
    }
    
    function updateLambdaOptLine0(selectedPerc) {
        let optLambdaIdx0 = IdxOpt0 ? IdxOpt0[selectedPerc] : 0;
        update2DPlot0(optLambdaIdx0, selectedPerc);

        const newPositions = [];
        const gNewPositions = [];

        for (let m = 0; m < M; m++) {
            newPositions.push(x[m], ghat0[optLambdaIdx0][m], lam[optLambdaIdx0]); // Lambda* Curve
            if (g !== null) gNewPositions.push(x[m], g[m], lam[optLambdaIdx0]); // g(x) at same λ*
        }

        lambdaOptLine0.geometry.setPositions(newPositions);
        lambdaOptLine0.material.resolution.set(
            document.getElementById("plot-container0-3d").clientWidth,
            document.getElementById("plot-container0-3d").clientHeight
        );

        if (g !== null){
            // Also update g(x) in 3D
            g3DLine0.geometry.setPositions(gNewPositions);
            g3DLine0.material.resolution.set(
                document.getElementById("plot-container0-3d").clientWidth,
                document.getElementById("plot-container0-3d").clientHeight
            );
        }
    }
    function updateLambdaOptLine2(selectedPerc) {
        let optLambdaIdx2 = IdxOpt2 ? IdxOpt2[selectedPerc] : 0;
        update2DPlot2(optLambdaIdx2, selectedPerc);

        const newPositions = [];
        const gNewPositions = [];

        for (let m = 0; m < M; m++) {
            newPositions.push(x[m], ghat2[optLambdaIdx2][m], lam[optLambdaIdx2]); // Lambda* Curve
            if (g !== null) gNewPositions.push(x[m], g[m], lam[optLambdaIdx2]); // g(x) at same λ*
        }

        lambdaOptLine2.geometry.setPositions(newPositions);
        lambdaOptLine2.material.resolution.set(
            document.getElementById("plot-container2-3d").clientWidth,
            document.getElementById("plot-container2-3d").clientHeight
        );

        if (g !== null){
            // Also update g(x) in 3D
            g3DLine2.geometry.setPositions(gNewPositions);
            g3DLine2.material.resolution.set(
                document.getElementById("plot-container2-3d").clientWidth,
                document.getElementById("plot-container2-3d").clientHeight
            );
        }
    }

    function updatePercSelection0(selectedPerc) {
        document.getElementById("percValue").innerText = selectedPerc.toFixed(0);

        // Get the optimal lambda index for the selected percentage
        let optLambdaIdx0 = (IdxOpt0 && IdxOpt0.length > selectedPerc) ? IdxOpt0[selectedPerc] : null;

        // Update λ_opt curve if valid
        if (optLambdaIdx0 !== null) {
            const newPositions = [];
            for (let m = 0; m < M; m++) {
                newPositions.push(x[m], ghat0[optLambdaIdx0][m], lam[optLambdaIdx0]);
            }
            lambdaOptLine0.geometry.setPositions(newPositions);
            lambdaOptLine0.material.resolution.set(
                document.getElementById("plot-container0-3d").clientWidth,
                document.getElementById("plot-container0-3d").clientHeight
            );
        }

        // First Pass: Update all peak colors normally (grey for killed, blue otherwise)
        for (let k = 0; k < K0; k++) {
            for (let l = 0; l < L; l++) {
                if (sigMat0[l][k] !== null && peakPoints0[k][l] !== null) {
                    if (sigMat0[l][k] <= selectedPerc) {
                        peakPoints0[k][l].material.color.set(0xaaaaaa);  // Grey for "killed" peaks
                        peakPoints0[k][l].material.opacity = 0.3; // 🔄 Reset opacity to default
                        peakPoints0[k][l].scale.set(1, 1, 1); // Reset size for grey markers
                    } else {
                        peakPoints0[k][l].material.color.set(0x000000);  // black for normal peaks
                        peakPoints0[k][l].material.opacity = 1; // 🔄 Reset opacity to default
                        peakPoints0[k][l].scale.set(1, 1, 1); // Reset size for normal peaks
                    }
                }
            }
        }

        // Second Pass: Ensure Green markers **ONLY on non-killed peaks**
        if (optLambdaIdx0 !== null) {
            for (let k = 0; k < K0; k++) {
                if (peakPoints0[k][optLambdaIdx0] !== null) {
                    // Only update if the peak **is NOT grey**
                    if (sigMat0[optLambdaIdx0][k] > selectedPerc) {
                        peakPoints0[k][optLambdaIdx0].material.color.set(0x00ffbb);
                        peakPoints0[k][optLambdaIdx0].material.opacity = 1;  // Green for optimal λ
                        peakPoints0[k][optLambdaIdx0].scale.set(1.5, 1.5, 1.5); // Make it slightly bigger!
                        // console.log("Green Marker:", k, optLambdaIdx0, peakPoints[k][optLambdaIdx0]);
                    }
                }
            }
        }
    }
    function updatePercSelection2(selectedPerc) {
        document.getElementById("percValue").innerText = selectedPerc.toFixed(0);

        // Get the optimal lambda index for the selected percentage
        let optLambdaIdx2 = (IdxOpt2 && IdxOpt2.length > selectedPerc) ? IdxOpt2[selectedPerc] : null;

        // Update λ_opt curve if valid
        if (optLambdaIdx2 !== null) {
            const newPositions = [];
            for (let m = 0; m < M; m++) {
                newPositions.push(x[m], ghat2[optLambdaIdx2][m], lam[optLambdaIdx2]);
            }
            lambdaOptLine2.geometry.setPositions(newPositions);
            lambdaOptLine2.material.resolution.set(
                document.getElementById("plot-container2-3d").clientWidth,
                document.getElementById("plot-container2-3d").clientHeight
            );
        }

        // First Pass: Update all peak colors normally (grey for killed, blue otherwise)
        for (let k = 0; k < K2; k++) {
            for (let l = 0; l < L; l++) {
                if (sigMat2[l][k] !== null && peakPoints2[k][l] !== null) {
                    if (sigMat2[l][k] <= selectedPerc) {
                        peakPoints2[k][l].material.color.set(0xaaaaaa);  // Grey for "killed" peaks
                        peakPoints2[k][l].material.opacity = 0.3; // 🔄 Reset opacity to default
                        peakPoints2[k][l].scale.set(1, 1, 1); // Reset size for grey markers
                    } else {
                        peakPoints2[k][l].material.color.set(0x000000);  // black for normal peaks
                        peakPoints2[k][l].material.opacity = 1; // 🔄 Reset opacity to default
                        peakPoints2[k][l].scale.set(1, 1, 1); // Reset size for normal peaks
                    }
                }
            }
        }

        // Second Pass: Ensure Green markers **ONLY on non-killed peaks**
        if (optLambdaIdx2 !== null) {
            for (let k = 0; k < K2; k++) {
                if (peakPoints2[k][optLambdaIdx2] !== null) {
                    // Only update if the peak **is NOT grey**
                    if (sigMat2[optLambdaIdx2][k] > selectedPerc) {
                        peakPoints2[k][optLambdaIdx2].material.color.set(0x00ffbb);
                        peakPoints2[k][optLambdaIdx2].material.opacity = 1;  // Green for optimal λ
                        peakPoints2[k][optLambdaIdx2].scale.set(1.5, 1.5, 1.5); // Make it slightly bigger!
                        // console.log("Green Marker:", k, optLambdaIdx0, peakPoints[k][optLambdaIdx0]);
                    }
                }
            }
        }
    }

    
    function syncCameras() {
        if (!camera3D0 || !camera3D2 || !controls3D0 || !controls3D2) {
            console.warn("Cameras or controls not initialized yet.");
            return;
        }

        controls3D0.addEventListener("change", () => {
            if (isSyncing) return;
            isSyncing = true;

            camera3D2.position.copy(camera3D0.position);
            camera3D2.quaternion.copy(camera3D0.quaternion);
            controls3D2.target.copy(controls3D0.target);
            controls3D2.update();

            isSyncing = false;
        });

        controls3D2.addEventListener("change", () => {
            if (isSyncing) return;
            isSyncing = true;

            camera3D0.position.copy(camera3D2.position);
            camera3D0.quaternion.copy(camera3D2.quaternion);
            controls3D0.target.copy(controls3D2.target);
            controls3D0.update();

            isSyncing = false;
        });

        console.log("Camera sync setup complete.");
    }

    // function animate3D0() {
    //     requestAnimationFrame(animate3D0);
    //     controls3D0.update();
        
    //     syncCameras();

    //     renderer3D0.render(scene3D0, camera3D0);
    // }

    // function animate3D2() {
    //     requestAnimationFrame(animate3D2);
    //     controls3D2.update();
        
    //     syncCameras();

    //     renderer3D2.render(scene3D2, camera3D2);
    // }
    function animate3D0() {
        requestAnimationFrame(animate3D0);
        controls3D0.update();
        renderer3D0.render(scene3D0, camera3D0);
    }

    function animate3D2() {
        requestAnimationFrame(animate3D2);
        controls3D2.update();
        renderer3D2.render(scene3D2, camera3D2);
    }

    function clearAllPlots() {
        console.log("Clearing all plots and freeing WebGL resources...");

        function clearScene(scene) {
            while (scene.children.length > 0) {
                let obj = scene.children[0];

                if (obj.geometry) {
                    obj.geometry.dispose();
                }

                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }

                scene.remove(obj);
            }
        }

            clearScene(scene3D0);
            clearScene(scene3D2);
            clearScene(scene2D0);
            clearScene(scene2D2);
            clearScene(scene_fig2);
        
        function removeRenderer(containerId) {
            const container = document.getElementById(containerId);
            if (container) {
                const oldRenderer = container.querySelector("canvas");
                if (oldRenderer) {
                    oldRenderer.remove(); // Remove canvas from DOM
                }
                if (container.renderer) {
                    container.renderer.dispose(); // Dispose WebGL context
                    container.renderer.forceContextLoss(); // Free GPU memory
                    container.renderer = null;
                }
            }
        }

        removeRenderer("plot-container0-3d");
        removeRenderer("plot-container2-3d");
        removeRenderer("plot-container0-2d");
        removeRenderer("plot-container2-2d");

        selectedLine0 = null; selectedLine2 = null;
        lambdaOptLine0 = null; lambdaOptLine2 = null;
        g2DLine0 = null; g2DLine2 = null;
        peakLines0 = []; peakLines2 = [];
        peakPoints0 = []; peakPoints2 = [];
        gLine_fig2 = null;

        console.log("All plots cleared successfully!");
    }
    function updateLegend(g) {
        const legendG = document.getElementById("legend-g");
        if (!g || g.every(value => value === null)) {  
            legendG.style.display = "none";  // Hide the legend if g is null
        } else {
            legendG.style.display = "flex";  // Show it if g exists
        }
    }

    // Get both dataset dropdowns
    const datasetSelector1 = document.getElementById("datasetSelector");
    const datasetSelector2 = document.getElementById("datasetSelector2");

    // Function to synchronize dropdowns
    function syncDatasetSelectors(sourceSelector, targetSelector) {
        targetSelector.value = sourceSelector.value; // Make both dropdowns match

        const selectedDataset = sourceSelector.value;  // Get the selected dataset filename
        
        const percSlider = document.getElementById("percSlider");
        percSlider.value = 0;  // Reset slider to 0
        
        const lambdaSlider = document.getElementById("lambdaSlider");
        lambdaSlider.value = 0;  // Reset slider to 0
        clearAllPlots();
        createPlots(selectedDataset);

        // Load dataset after syncing
        // clearAllPlots();  // Clear previous plots
        // createPlots(sourceSelector.value);  // Load selected dataset
    }

    // Add event listeners to both dropdowns
    datasetSelector1.addEventListener("change", function () {
        syncDatasetSelectors(datasetSelector1, datasetSelector2);
    });

    datasetSelector2.addEventListener("change", function () {
        syncDatasetSelectors(datasetSelector2, datasetSelector1);
    });

    document.getElementById("lambdaSlider").addEventListener("input", (event) => {
        const lambdaIdx = parseInt(event.target.value);
        updateLamSelection(lambdaIdx);
    });

    // Call this function after loading the dataset
    document.getElementById("percSlider").addEventListener("input", (event) => {
        const percValue = parseInt(event.target.value);
        updateLambdaOptValue0(percValue);
        updateLambdaOptValue2(percValue);
    });
        
    // document.getElementById("datasetSelector").addEventListener("change", (event) => {
    //     const selectedDataset = event.target.value;  // Get the selected dataset filename
        
    //     const percSlider = document.getElementById("percSlider");
    //     percSlider.value = 0;  // Reset slider to 0
        
    //     const lambdaSlider = document.getElementById("lambdaSlider");
    //     lambdaSlider.value = 0;  // Reset slider to 0
    //     clearAllPlots();
    //     createPlots(selectedDataset);
    // });
    
    createPlots("data1.json");

</script>
</body>
</html>