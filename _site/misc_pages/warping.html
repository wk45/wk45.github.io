<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simple Warping Visualization (500px)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
      :root {
        --text: #333333;
        --muted: #666666;
        --bg: #f7f7f5;
        --surface: #ffffff;
        --grid: #e0e0e0;
        --frame: #333333;
        --ghost: #cccccc;
        --note: #a64034;
        --control-fill: #ffffff;
        --halo: #ffffff;
      }

      html[data-theme="dark"] {
        --text: #e6e6e6;
        --muted: #b8b8b8;
        --bg: #0f1115;
        --surface: #171a21;
        --grid: #2a2f3a;
        --frame: #d7d7d7;
        --ghost: #6b7280;
        --note: #cf7166;
        --control-fill: #171a21;
        --halo: #0f1115;
      }

      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: var(--surface);
        font-family: "IBM Plex Sans", "Segoe UI", Helvetica, Arial, sans-serif;
        color: var(--text);
        padding: 20px 0;
        font-size: 14px;
        line-height: 1.4;
      }
      
      /* Card fixed to 500px */
      .card {
        width: 100%;
        max-width: 500px;
        background: var(--surface);
        border: none;
        box-shadow: none;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      #canvas-wrapper { width: 100%; background: var(--surface); }

      /* Legend Area */
      .legend-panel {
        padding: 8px 0;
        background: transparent;
        display: flex;
        justify-content: center;
        width: 100%;
      }

      .legend { 
        display: flex; 
        justify-content: center; 
        gap: 15px; 
        font-size: 0.75rem; 
        color: var(--muted);
        flex-wrap: wrap; 
      }
      
      .legend-item { display: flex; align-items: center; gap: 5px; white-space: nowrap; }
      
      .line-icon { width: 16px; height: 3px; border-radius: 2px; }
      .ghost-icon { width: 16px; height: 3px; background: var(--ghost); border-radius: 2px; }
      .dot { width: 8px; height: 8px; border-radius: 50%; }
      .note { color: var(--note); }

    </style>
  </head>
  <body>
    <span class="note"><i>(Drag the red points to see how γ(t) warps f(t).)</i></span>

    <div class="card" id="mainCard">
      <div id="canvas-wrapper"></div>
      
      <div class="legend-panel">
        <div class="legend">
          <div class="legend-item"><span class="line-icon" style="background:#E15759;"></span> γ(t)</div>
          <div class="legend-item"><span class="line-icon" style="background:#4E79A7;"></span> Warped f(γ(t))</div>
          <div class="legend-item"><span class="ghost-icon"></span> Original</div>
          <div class="legend-item"><span class="dot" style="background:#00b894;"></span> Max</div>
          <div class="legend-item"><span class="dot" style="background:#fdcb6e;"></span> Min</div>
        </div>
      </div>
    </div>

    <script>
      // --- Constants ---
      const cBlue = '#4E79A7';
      const cRed = '#E15759';
      const cMax = '#00b894';
      const cMin = '#fdcb6e';
      let cGrid = '#e0e0e0';
      let cFrame = '#333333';
      let cText = '#666666';
      let cGhost = '#cccccc';
      let cControlFill = '#ffffff';
      let cHalo = '#ffffff';
      let cCanvas = '#ffffff';
      let cBg = '#ffffff';
      const cPulse = [124, 180, 255];

      // --- State ---
      const N = 200; 
      let cp1 = { x: 0.33, y: 0.33 };
      let cp2 = { x: 0.66, y: 0.66 };
      let dragging = null;
      let originalExtrema = [];

      // Layout Variables - 여백을 늘려서 라벨 공간 확보
      let plotSize = 0;
      let margin = 35; // 기존 15에서 35로 증가 (라벨 잘림 해결)
      let gap = 30;    // 그래프 사이 간격 조정
      let stacked = false;
      let hasInteracted = false;

      function readCssVar(name, fallback) {
        var value = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return value || fallback;
      }

      function updateThemeColors() {
        cGrid = readCssVar('--grid', cGrid);
        cFrame = readCssVar('--frame', cFrame);
        cText = readCssVar('--muted', cText);
        cGhost = readCssVar('--ghost', cGhost);
        cControlFill = readCssVar('--control-fill', cControlFill);
        cHalo = readCssVar('--halo', cHalo);
        cCanvas = readCssVar('--surface', cCanvas);
        cBg = readCssVar('--surface', cBg);
        document.body.style.backgroundColor = cBg;
      }

      function setTheme(theme) {
        if (!theme) return;
        document.documentElement.setAttribute('data-theme', theme);
        updateThemeColors();
      }

      function applyThemeFromParent() {
        try {
          var parentTheme = window.parent.document.documentElement.getAttribute('data-theme');
          if (parentTheme) setTheme(parentTheme);
        } catch (e) {
          updateThemeColors();
        }
      }

      window.addEventListener('message', function (event) {
        if (event.data && event.data.type === 'theme') setTheme(event.data.theme);
      });

      function setup() {
        applyThemeFromParent();
        let container = document.getElementById('mainCard');
        let w = container.getBoundingClientRect().width;
        
        calcLayout(w);
        let c = createCanvas(w, calcTotalHeight());
        c.parent('canvas-wrapper');
        
        findOriginalExtrema();
      }

      function windowResized() {
        let container = document.getElementById('mainCard');
        if(!container) return;
        let w = container.getBoundingClientRect().width;
        calcLayout(w);
        resizeCanvas(w, calcTotalHeight());
      }

      function calcLayout(w) {
        if (w < 400) {
            stacked = true;
            margin = 35; 
            gap = 30;
            plotSize = w - (margin * 2); 
        } else {
            stacked = false;
            margin = 35; // 여백 확보
            gap = 30;
            // 500px 너비에서 여백 빼고 남은 공간을 반으로 나눔
            plotSize = (w - (margin * 2) - gap) / 2;
        }
      }

      function calcTotalHeight() {
        return stacked ? (margin + plotSize + gap + plotSize + margin) : (margin + plotSize + margin);
      }

      function draw() {
        background(cCanvas);
        
        // 1. Left Plot (Gamma)
        push();
        translate(margin, margin);
        drawLeftPlot();
        pop();

        // 2. Right Plot (Signal)
        push();
        if (stacked) {
            translate(margin, margin + plotSize + gap);
        } else {
            translate(margin + plotSize + gap, margin);
        }
        drawRightPlot();
        pop();
      }

      // --- Left Plot: Warping Function ---
      function drawLeftPlot() {
        drawAxes(plotSize, "Time (t)", "Warped Time γ(t)");
        
        stroke(cGhost); strokeWeight(1); drawingContext.setLineDash([4, 4]);
        line(0, plotSize, plotSize, 0); drawingContext.setLineDash([]);

        noFill(); stroke(cRed); strokeWeight(2.5);
        beginShape();
        for (let i = 0; i <= N; i++) {
          let t = i / N;
          let val = getGamma(t);
          vertex(t * plotSize, (1 - val) * plotSize);
        }
        endShape();
        
        // Inverse Mapping Dots
        for(let pt of originalExtrema) {
            let tNew = findInverseGamma(pt.t);
            if(tNew !== null) {
                let px = tNew * plotSize;
                let py = (1 - pt.t) * plotSize; 
                fill(pt.type === 'max' ? cMax : cMin); noStroke();
                circle(px, py, 6);
            }
        }
        
        drawControlPoint(cp1);
        drawControlPoint(cp2);
      }

      // --- Right Plot: Signal ---
      function drawRightPlot() {
        drawAxes(plotSize, "Time (t)", "Amplitude");

        // Ghost Signal (Original) - No dots as requested
        noFill(); stroke(cGhost); strokeWeight(1.5);
        beginShape();
        for (let i = 0; i <= N; i++) {
          let t = i / N;
          vertex(t * plotSize, mapSignal(getSignal(t)));
        }
        endShape();

        // Warped Signal
        noFill(); stroke(cBlue); strokeWeight(2.5);
        beginShape();
        for (let i = 0; i <= N; i++) {
          let t = i / N;
          let gamma = getGamma(t); 
          vertex(t * plotSize, mapSignal(getSignal(gamma)));
        }
        endShape();
        
        // Tracked Extrema (Only on Warped Signal)
        for(let pt of originalExtrema) {
            let tNew = findInverseGamma(pt.t);
            if(tNew !== null) {
                let px = tNew * plotSize;
                let py = mapSignal(pt.val); 
                stroke(cHalo); strokeWeight(1.5); 
                fill(pt.type === 'max' ? cMax : cMin);
                circle(px, py, 8);
            }
        }
      }

      // --- Signal Function ---
      function getSignal(t) {
        return Math.sin(2 * Math.PI * t) - 0.4 * Math.sin(4 * Math.PI * t);
      }
      
      function mapSignal(val) { return map(val, -1.8, 1.8, plotSize, 0); }

      function findOriginalExtrema() {
          originalExtrema = [];
          let prev = getSignal(0);
          let dPrev = 0; 
          for(let i=1; i<=N; i++) {
              let t = i/N;
              let curr = getSignal(t);
              let slope = curr - prev;
              if (i > 1 && Math.sign(slope) !== Math.sign(dPrev) && dPrev !== 0) {
                  let type = (dPrev > 0) ? 'max' : 'min';
                  originalExtrema.push({ t: (i-0.5)/N, val: prev, type: type });
              }
              prev = curr;
              dPrev = slope;
          }
      }

      // --- Robust Math ---
      function getGamma(t) {
         const x = [0, cp1.x, cp2.x, 1];
         const y = [0, cp1.y, cp2.y, 1];
         let i = 0; while (i < 2 && t > x[i + 1]) i++;
         const h = x[i + 1] - x[i]; if (h <= 0) return y[i];
         const u = (t - x[i]) / h;
         const m = pchipSlopes(x, y);
         return hermite(y[i], y[i + 1], m[i], m[i + 1], u, h);
      }

      function findInverseGamma(targetVal) {
          let low = 0, high = 1;
          for(let k=0; k<15; k++) { 
              let mid = (low + high) / 2;
              let g = getGamma(mid);
              if(g < targetVal) low = mid; else high = mid;
          }
          return (low + high) / 2;
      }

      function hermite(y0, y1, m0, m1, t, h) {
        const t2 = t*t, t3 = t2*t;
        return (2*t3 - 3*t2 + 1)*y0 + (t3 - 2*t2 + t)*m0*h + (-2*t3 + 3*t2)*y1 + (t3 - t2)*m1*h;
      }

      function pchipSlopes(x, y) {
        const m = [0,0,0,0], h = [], delta = [];
        for (let i=0; i<3; i++) { h.push(x[i+1]-x[i]); delta.push((y[i+1]-y[i])/h[i]); }
        m[0] = delta[0]; m[3] = delta[2];
        for (let i=1; i<3; i++) {
            if (delta[i-1]*delta[i] > 0) {
                let w1 = 2*h[i] + h[i-1], w2 = h[i] + 2*h[i-1];
                m[i] = (w1+w2) / (w1/delta[i-1] + w2/delta[i]);
            } else m[i] = 0;
        }
        return m;
      }

      // --- Interaction ---
      function mousePressed() {
        hasInteracted = true;
        let mx = mouseX - margin; let my = mouseY - margin;
        if (mx < 0 || mx > plotSize || my < 0 || my > plotSize) return;
        let r = 20; 
        if (dist(mx, my, cp1.x*plotSize, (1-cp1.y)*plotSize) < r) dragging = 'cp1';
        else if (dist(mx, my, cp2.x*plotSize, (1-cp2.y)*plotSize) < r) dragging = 'cp2';
      }

      function mouseDragged() {
        hasInteracted = true;
        if (!dragging) return;
        let mx = mouseX - margin, my = mouseY - margin;
        let valX = constrain(mx/plotSize, 0, 1);
        let valY = constrain(1-(my/plotSize), 0, 1);
        const pad = 0.02;

        if (dragging === 'cp1') {
          valX = constrain(valX, 0, cp2.x - pad);
          valY = constrain(valY, 0, cp2.y - pad);
          cp1.x = valX; cp1.y = valY;
        } else if (dragging === 'cp2') {
          valX = constrain(valX, cp1.x + pad, 1);
          valY = constrain(valY, cp1.y + pad, 1);
          cp2.x = valX; cp2.y = valY;
        }
      }
      function mouseReleased() { dragging = null; }

      // --- Visual Helpers ---
      function drawAxes(size, xLabel, yLabel) {
        stroke(cGrid); strokeWeight(1);
        for(let i=1; i<5; i++) { let p = i*size/5; line(p,0,p,size); line(0,p,size,p); }
        
        stroke(cFrame); noFill(); rect(0,0,size,size);
        
        noStroke(); fill(cText); textSize(10); 
        // x-label 위치 조정 (조금 더 아래로)
        textAlign(CENTER, TOP); text(xLabel, size/2, size+10);
        
        // y-label 위치 조정 (왼쪽으로 더 밀어서 잘림 방지)
        push(); translate(-18, size/2); rotate(-HALF_PI); 
        textAlign(CENTER, BOTTOM); text(yLabel, 0, 0); pop();
      }

      function drawControlPoint(pt) {
        let px = pt.x*plotSize, py = (1-pt.y)*plotSize;
        if (!hasInteracted) {
          let glow = 40 + 25 * Math.sin(frameCount * 0.06);
          noStroke(); fill(cPulse[0], cPulse[1], cPulse[2], glow);
          circle(px, py, 22);
        }
        noStroke(); fill(0,0,0,20); circle(px, py, 16); 
        stroke(cRed); strokeWeight(2); fill(cControlFill); circle(px, py, 10);
        noStroke(); fill(cRed); circle(px, py, 4);
      }
    </script>
  </body>
</html>
